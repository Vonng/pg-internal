# 第十章 基础备份与时间点恢复

[TOC]

​	在线数据库备份大致可分为两类：逻辑备份和物理备份。它们有着各自的优点和缺点。虽然它们都有优点和缺点，但逻辑备份有一个缺点：执行需要花费太多时间。特别是，需要花费很长时间来备份大型数据库，甚至需要更多时间从备份数据中恢复这样的数据库。相反，物理备份可以在相对较短的时间内备份和恢复大型数据库，因此在实际系统中它是一个非常重要和有用的功能。

​	在PostgreSQL中，自8.0版本开始提供在线物理完全备份，而正在运行的整个数据库集群（即物理备份数据）的快照称为**基本备份（base backup）**。

​	从8.0版开始提供的**时间点恢复（Point-In-Time Recovery, PITR）**是使用由连续归档功能创建的基本备份和归档日志将数据库群集恢复到任何时间点的功能。例如，即使你犯了一个严重错误（例如TRUNCATE所有表），此功能使您可以在错误发生之前恢复该点的数据库。

本章描述了以下主题：

* 什么是基础备份
* PITR的工作原理
* 时间线ID是什么
* 时间线历史文件是什么

> 在7.4或更早版本中，PostgreSQL仅支持逻辑备份（逻辑的完全备份、部分备份与数据导出）。



## 10.1 基础备份

首先，使用低级命令进行基本备份的标准过程如下所示：

1. 发出`pg_start_backup`命令

2. 使用你想用的归档命令获取数据库群集的快照
3. 发出`pg_stop_backup`命令

这个简单的过程对于DBA来说很容易使用，因为它不需要特殊工具，只需要常用工具（如复制命令或类似的归档工具）来创建基本备份。此外，在此过程中，不需要表锁，并且所有用户都可以在不受备份操作影响的情况下发出查询。这些优于其他主要的开源RDBMS。

制作基本备份的更简单方法是使用`pg_basebackup`实用程序，但它在内部发出这些低级命令。

**图10.1 进行基本备份**

![](img/fig-10-01.png)


由于这些命令对显然是理解PITR的关键点之一，我们将在以下小节中探讨它们。

>
> `pg_start_backup`和`pg_stop_backup`命令定义在：src/backend/access/transam/xlogfuncs.c。



### 10.1.1 pg_start_backup

`pg_start_backup`准备进行基本备份。如第9.8节所述，恢复过程从REDO点开始，因此pg_start_backup必须执行检查点以在进行基本备份时显式创建REDO点。此外，其检查点的检查点位置必须保存在pg_control以外的文件中，因为在备份期间可能会多次执行常规检查点。因此，`pg_start_backup`执行以下四个操作：

1. 强制进入整页写入模式。
2. 切换到当前的WAL段文件（版本8.4或更高版本）。
3. 执行存盘。
4. 创建backup_label文件 - 此文件在基本目录的顶级创建，包含有关基本备份本身的基本信息，例如此检查点的检查点位置。

第三和第四次行动是这一命令的核心;执行第一和第二操作以更可靠地恢复数据库集群。

backup_label文件包含以下六个项目（版本11或更高版本，七个项目）：

* 检查点位置 - 这是记录此命令创建的检查点的LSN位置。
* START WAL LOCATION - 这不是与PITR一起使用，而是与第11章中描述的流复制一起使用。它被命名为“START WAL LOCATION”，因为复制模式下的备用服务器在初始启动时只读取一次该值。
* 备份方法 - 这是用于进行此基本备份的方法。 （'pg_start_backup'或'pg_basebackup'。）
* BACKUP FROM - 显示此备份是从主数据库还是备用数据库获取。
* START TIME - 这是执行pg_start_backup时的时间戳。
* LABEL - 这是pg_start_backup中指定的标签。
* START TIMELINE - 这是备份开始的时间表。这是为了进行健全性检查，并已在版本11中引入。



> #### 备份标签
>
> 一个9.6版本中备份标签的实际例子如下所示：
>
> ```bash
> postgres> cat /usr/local/pgsql/data/backup_label
> START WAL LOCATION: 0/9000028 (file 000000010000000000000009)
> CHECKPOINT LOCATION: 0/9000060
> BACKUP METHOD: pg_start_backup
> BACKUP FROM: master
> START TIME: 2018-7-9 11:45:19 GMT
> LABEL: Weekly Backup
> ```

您可以想象，当您使用此基本备份恢复数据库时，PostgreSQL从backup_label文件中取出“CHECKPOINT LOCATION”以从相应的存档日志中读取检查点记录，然后从其记录中获取REDO点并开始 恢复过程。 （详细信息将在下一节中介绍。）

### 10.1.2 pg_stop_backup

`pg_stop_backup`执行以下五个操作以完成备份。

1. 如果已被`pg_start_backup`强制更改，则重置为非整页写入模式。
2. 写一个备份结束的XLOG记录。
3. 切换WAL段文件。
4. 创建备份历史记录文件 —— 此文件包含backup_label文件的内容以及已执行`pg_stop_backup`的时间戳。
5. 删除backup_label文件 —— 从基本备份恢复需要backup_label文件，一旦复制，在原始数据库集群中不需要。

> 备份历史文件的命名方法如下所示：
>
> ```
> {WAL segment}.{offset value at the time the base backup was started}.backup
> ```



## 10.2 时间点恢复（PITR）的工作原理

图10.2显示了PITR的基本概念。 PITR模式下的PostgreSQL重放基本备份上的存档日志的WAL数据，从pg_start_backup创建的REDO点到您要恢复的点。在PostgreSQL中，要恢复的点被称为恢复目标。

**图10.2 PITR的基本概念**

![](img/fig-10-02.png)

以下是PITR如何工作的描述。假设您在2018年7月9日格林威治标准时间12点05分出错。您应该删除数据库集群并使用之前使用的基本备份恢复新数据库集群。然后，创建一个recovery.conf文件，并在您犯错的位置设置此文件中参数recovery_target_time的时间（在本例中为格林尼治标准时间12:05）。 recovery.conf文件如下所示：

```bash
＃将存档日志放在/ mnt / server / archivedir目录下。

restore_command ='cp / mnt / server / archivedir /％f％p'

recovery_target_time =“2018-7-9 12:05 GMT”

```

当PostgreSQL启动时，如果数据库集群中有recovery.conf和backup_label，它将进入PITR模式。

PITR过程几乎与第9章中描述的正常恢复过程相同;它们之间的唯一区别是以下两点：

1. WAL段/存档日志从哪里读取？
   * 正常恢复模式 - 来自基目录下的pg_xlog子目录（版本10或更高版本，pg_wal子目录）。
   * PITR模式 - 来自配置参数archive_command中设置的归档目录。
2. 检查点位置从哪里读取？
   * 正常恢复模式 - 来自pg_control文件。
   * PITR模式 - 来自backup_label文件。

PITR流程概述如下：

1. 为了找到REDO点，PostgreSQL使用内部函数read_backup_label从backup_label文件中读取'CHECKPOINT LOCATION'的值。

2. PostgreSQL从recovery.conf中读取一些参数值;在此示例中，restore_command和recovery_target_time。

3. PostgreSQL开始从REDO点重放WAL数据，可以从'CHECKPOINT LOCATION'的值中轻松获得。 WAL数据从存档日志中读取，存档日志通过执行参数resotere_command中写入的命令从存档区域复制到临时区域。 （使用后删除临时区域中复制的日志文件。）

   在此示例中，PostgreSQL从REDO点读取并重放WAL数据到时间戳'2018-7-9 12:05:00'之前的数据，因为参数recovery_target_time设置为此时间戳。如果恢复目标未设置为recovery.conf，则PostgreSQL将重播，直到归档日志结束。

4. 当恢复过程完成时，在pg_xlog子目录中创建时间历史文件，例如'00000002.history'（版本10或更高版本，pg_wal子目录）;如果启用了归档日志功能，则还会在归档目录中创建相同的命名文件。以下各节介绍了此文件的内容和作用。

提交和中止操作的记录包含每个操作已完成的时间戳（两个操作的XLOG数据部分分别在xl_xact_commit和xl_xact_abort中定义）。因此，如果将目标时间设置为参数recovery_target_time，PostgreSQL可以选择是否继续恢复，只要它重放提交或中止操作的XLOG记录。当重放每个动作的XLOG记录时，PostgreSQL会比较目标时间和记录中写入的每个时间戳;如果时间戳超过目标时间，PITR过程将完成。

>
> 函数read_backup_label在src / backend / access / transam / xlog.c中定义。
> 结构xl_xact_commit和xl_xact_abort在src / include / access / xact.h中定义。
>

> ####  为什么我们可以使用通用归档工具进行基本备份？
>
> 恢复过程是使数据库集群处于一致状态的过程，尽管集群不一致。由于PITR基于恢复过程，即使基本备份是一堆不一致的文件，它也可以恢复数据库集群。这就是我们可以在没有文件系统快照功能或特殊工具的情况下使用通用归档工具的原因。



## 10.3 时间线与时间线历史文件

PostgreSQL中的时间轴用于区分原始数据库集群和恢复的数据库集群，是PITR的核心概念。在本节中，描述了与时间线相关的两件事：timelineId和时间轴历史文件。

### 10.3.1 时间线标识（TimelineID）

每个时间线都给出一个相应的时间线Id，一个从1开始的4字节无符号整数。

为每个数据库集群分配一个单独的timelineId。 initdb实用程序创建的原始数据库集群的timelineId为1.每当数据库集群恢复时，timelineId将增加1.例如，在上一节的示例中，从原始集群恢复的集群的timelineId为2。

图10.3从时间轴Id的角度说明了PITR过程。首先，我们删除当前的数据库集群并恢复过去的基本备份，以便返回到恢复的起始点，并且这种情况在图中的红色箭头曲线中表示。接下来，我们启动PostgreSQL服务器，它通过跟踪初始时间线（timelineId 1），从pg_start_backup创建的REDO点重放存档日志中的WAL数据，直到恢复目标，并且这种情况在蓝色箭头行中表示。数字。然后，为恢复的数据库集群分配新的timelineId 2，并在新的时间轴上运行PostgreSQL。

**图10.3 原始数据库集群和恢复数据库集群之间的timelineId的关系**

![](img/fig-10-03.png)



​	正如第9章中简要提到的，WAL段文件名的前8位数等于为每个段创建的数据库集群的timelineId。当timelineId改变时，WAL段文件名也将被改变。

​	关注WAL段文件，将再次描述恢复过程。假设我们使用两个存档日志'000000010000000000000009'和'00000001000000000000000A'恢复数据库集群。新恢复的数据库集群被分配了timelineId 2，PostgreSQL从'00000002000000000000000A'创建了WAL段。图10.4显示了这种情况。

**图10.4 原始数据库集群和恢复数据库集群之间的WAL段文件的关系**

![](img/fig-10-04.png)



### 10.3.2 时间线历史文件

当PITR进程完成时，会在归档目录和pg_xlog子目录（版本10或更高版本，pg_wal子目录）下创建名称为“00000002.history”的时间轴历史记录文件。此文件记录从哪个时间轴分支出来的时间。

此文件的命名规则如下所示：

```
“8位数的新时间线”.history
```

时间轴历史文件至少包含一行，每行由以下三项组成：

* timelineId - 用于恢复的存档日志的timelineId。
* LSN - WAL段切换发生的LSN位置。
* 原因 - 时间线改变原因的人类可读解释。

具体示例如下所示：

```bash
postgres> cat /home/postgres/archivelogs/00000002.history
1	  0/A000198	before 2018-7-9 12:05:00.861324+00
```

含义如下：

> 数据库集群（timelineId = 2）基于timelineId为1的基本备份，并在“2018-7-9 12：05：00.861324 + 00”之前的时间内通过重播存档日志恢复到0 / A000198。

通过这种方式，每个时间轴历史文件都会告诉我们各个恢复的数据库集群的完整历史记录。而且，它也用于PITR过程本身。详细信息将在下一节中介绍。

>
> 版本9.3中更改了时间轴历史记录文件格式。版本9.3或更高版本及更早版本的格式如下所示，但未详细说明。
>
> 9.3及后续版本：
>
> ```
> timelineId	LSN	"reason"
> ```
>
> 9.2及先前版本
>
> ```
> timelineId	WAL_segment	"reason"
> ```



## 10.4 时间点恢复与时间线历史文件

时间线历史文件在第二个和后续PITR过程中起着重要作用。通过尝试第二次恢复，我们将探索如何使用它。

同样，假设您在12:15:00在timelineId为2的已恢复数据库集群中出错。在这种情况下，要恢复数据库集群，您应该创建一个新的recovery.conf，如下所示：

```bash
restore_command ='cp / mnt / server / archivedir /％f％p'

recovery_target_time =“2018-7-9 12:15:00 GMT”

recovery_target_timeline = 2

```

​	参数`recovery_target_time`设置您犯了新错误的时间，并且`recovery_target_timeline`设置为'2'，以便沿其时间线恢复。

重新启动PostgreSQL服务器并进入PITR模式以在时间线Id 2的目标时间恢复数据库。参见图10.5。

**图10.5 沿着timelineId 2在12:15:00恢复数据库**

![](img/fig-10-05.png)

1. PostgreSQL从backup_label文件中读取`CHECKPOINT LOCATION`的值。

2. 从recovery.conf中读取一些参数值;在此示例中，`restore_command`，`recovery_target_time`和`recovery_target_timeline`。

3. PostgreSQL读取时间轴历史文件'00000002.history'，该文件对应于参数recovery_target_timeline的值。

4. PostgreSQL通过以下步骤重放WAL数据：

   1. 从REDO点到写在00000002.history文件中的LSN'0 / A000198'，PostgreSQL读取并重放时间轴Id为1的相应存档日志的WAL数据。
   2. 从LSN'0 / A000198'之后的那个到时间戳'2018-7-9 12:15:00'之前的那个，PostgreSQL读取并重放时间轴Id为2的WAL数据（适当的存档日志）。

5. 当恢复过程完成时，当前timelineId将前进到3，并在pg_xlog子目录（pg_wal子目录，如果版本10或更高版本）和归档目录中创建名为00000003.history的新时间线历史文件。

   ```bash
   postgres> cat /home/postgres/archivelogs/00000003.history
   1         0/A000198     before 2018-7-9 12:05:00.861324+00
   
   2         0/B000078     before 2018-7-9 12:15:00.927133+00
   ```

当您多次执行PITR时，应明确设置timelineId以使用适当的时间轴历史记录文件。

这样，时间轴历史文件不仅是数据库集群的历史日志，还是PITR过程的恢复指令文档。